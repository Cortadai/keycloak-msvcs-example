# ===============================================
# CONFIGURACI√ìN DEL API GATEWAY
# ===============================================
# El Gateway es el punto de entrada √öNICO a todos los microservicios
# Aqu√≠ es donde se hace la PRIMERA validaci√≥n del JWT

server:
  port: 8081

spring:
  application:
    name: gateway

  # ===============================================
  # CLOUD GATEWAY - Routing Configuration
  # ===============================================
  cloud:
    gateway:
      # ==========================================
      # RUTAS - Definen c√≥mo enrutar requests
      # ==========================================
      routes:
        # ==========================================
        # RUTA 1: User Service
        # ==========================================
        - id: user-service
          # Destino: user-service registrado en Eureka
          # lb:// = load balanced (Eureka resuelve la IP)
          uri: lb://user-service

          # Predicados: cu√°ndo aplicar esta ruta
          predicates:
            - Path=/api/users/**

          # Filtros: modificar el request antes de enviarlo
          filters:
            # NO reescribir path - mantener /api porque el microservicio
            # tiene context-path: /api configurado

            # üîê JWT Propagation Filter (custom)
            # Este filtro AGREGA el JWT al header del request interno
            - name: JWTPropagation

        # ==========================================
        # RUTA 2: Product Service
        # ==========================================
        - id: product-service
          uri: lb://product-service
          predicates:
            - Path=/api/products/**
          filters:
            - name: JWTPropagation

        # ==========================================
        # RUTA 3: Order Service
        # ==========================================
        - id: order-service
          uri: lb://order-service
          predicates:
            - Path=/api/orders/**
          filters:
            - name: JWTPropagation

      # ==========================================
      # GLOBAL FILTERS - Aplican a TODAS las rutas
      # ==========================================
      default-filters: []
        # Rate Limiting (prevenir abuse) - DESACTIVADO (requiere Redis)
        # Para activarlo, descomentar y agregar dependencia spring-boot-starter-data-redis-reactive
        # - name: RequestRateLimiter
        #   args:
        #     redis-rate-limiter:
        #       replenishRate: 10  # 10 requests per second
        #       burstCapacity: 20  # burst de hasta 20

      # ==========================================
      # DISCOVERY - Integraci√≥n con Eureka
      # ==========================================
      discovery:
        locator:
          enabled: true  # Habilita rutas autom√°ticas basadas en Eureka
          lower-case-service-id: true

# ===============================================
# üîê SEGURIDAD - JWT VALIDATION EN GATEWAY
# ===============================================
# Esta configuraci√≥n hace que el Gateway valide TODOS los JWT
# ANTES de enrutar a los microservicios

  security:
    oauth2:
      resourceserver:
        jwt:
          # Heredado de application.yml (Config Server)
          # issuer-uri: http://localhost:8080/realms/mi-realm
          # jwk-set-uri: http://localhost:8080/realms/mi-realm/protocol/openid-connect/certs

          # Configuraci√≥n adicional espec√≠fica del Gateway
          # (si es necesario)

# ===============================================
# CIRCUIT BREAKER - Resilience4j
# ===============================================
# Si un microservicio falla, el Circuit Breaker lo detecta
# y evita enviarle m√°s requests (fail fast)

resilience4j:
  circuitbreaker:
    configs:
      default:
        # Configuraci√≥n por defecto para todos los circuit breakers
        sliding-window-size: 10
        minimum-number-of-calls: 5
        failure-rate-threshold: 50
        wait-duration-in-open-state: 10000  # 10 segundos
        permitted-number-of-calls-in-half-open-state: 3

    instances:
      # Circuit breaker espec√≠fico para user-service
      user-service:
        base-config: default

      product-service:
        base-config: default

      order-service:
        base-config: default

  # Configuraci√≥n de Retry (reintentos)
  retry:
    configs:
      default:
        max-attempts: 3
        wait-duration: 1000  # 1 segundo entre reintentos

# ===============================================
# LOGGING - Logs espec√≠ficos del Gateway
# ===============================================
logging:
  level:
    org.springframework.cloud.gateway: DEBUG
    org.springframework.security: DEBUG
    reactor.netty: INFO

# ===============================================
# ¬øC√ìMO FUNCIONA EL FLUJO DE JWT EN EL GATEWAY?
# ===============================================
#
# 1. REQUEST LLEGA AL GATEWAY
#    POST http://localhost:8081/api/users/me
#    Header: Authorization: Bearer eyJhbGc...
#
# 2. GATEWAY VALIDA EL JWT (Spring Security)
#    - Descarga claves p√∫blicas de Keycloak (jwk-set-uri)
#    - Valida firma del JWT
#    - Valida expiraci√≥n (exp claim)
#    - Valida issuer (iss claim)
#    - Si falla ‚Üí 401 Unauthorized
#    - Si OK ‚Üí contin√∫a
#
# 3. GATEWAY APLICA FILTROS
#    - JWTPropagationFilter: Agrega JWT al header del request interno
#    - Rate Limiter: Verifica l√≠mites
#    - Circuit Breaker: Verifica estado del servicio
#
# 4. GATEWAY ENRUTA AL MICROSERVICIO
#    - Consulta Eureka: ¬øD√≥nde est√° user-service?
#    - Eureka responde: localhost:8082
#    - Gateway env√≠a: GET http://localhost:8082/users/me
#                     Header: Authorization: Bearer eyJhbGc...
#
# 5. MICROSERVICIO RECIBE Y VALIDA (Defense in Depth)
#    - User Service TAMBI√âN valida el JWT
#    - Doble validaci√≥n = m√°s seguro
#    - Si falla ‚Üí 401
#    - Si OK ‚Üí procesa y responde
#
# 6. GATEWAY RETORNA RESPUESTA AL CLIENTE
#    - Response del microservicio ‚Üí Cliente
#
# ===============================================
# VENTAJAS DE VALIDAR EN GATEWAY:
# ===============================================
# ‚úÖ Validaci√≥n centralizada (un solo punto)
# ‚úÖ Microservicios no reciben requests inv√°lidos
# ‚úÖ Reduce carga en microservicios
# ‚úÖ F√°cil de monitorear y auditar
#
# ¬øPOR QU√â TAMBI√âN VALIDAR EN MICROSERVICIOS?
# ===============================================
# ‚úÖ Defense in depth (seguridad en capas)
# ‚úÖ Microservicios pueden ser llamados directamente (ej: inter-service)
# ‚úÖ Zero trust architecture
# ‚úÖ Si el Gateway es comprometido, microservicios siguen seguros
