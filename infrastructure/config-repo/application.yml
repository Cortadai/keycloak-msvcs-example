# ===============================================
# CONFIGURACI√ìN COMPARTIDA POR TODOS LOS SERVICIOS
# ===============================================
# Este archivo se aplica a TODOS los microservicios
# Contiene la configuraci√≥n JWT que todos necesitan

# ===============================================
# üîê CONFIGURACI√ìN DE SEGURIDAD JWT
# ===============================================
# Esta es la parte M√ÅS IMPORTANTE para entender
# c√≥mo los microservicios validan tokens JWT

spring:
  security:
    oauth2:
      resourceserver:
        jwt:
          # ==========================================
          # issuer-uri: ¬øQui√©n emiti√≥ el token?
          # ==========================================
          # Keycloak incluye un "iss" claim en cada JWT que genera.
          # Spring Security verifica que coincida con este valor.
          #
          # Formato: http://{keycloak-host}/realms/{realm-name}
          #
          # ‚ö†Ô∏è IMPORTANTE: Este debe coincidir EXACTAMENTE con el
          # claim "iss" del JWT, sino falla la validaci√≥n
          #
          # üîß CONFIGURACI√ìN POR VARIABLES DE ENTORNO:
          # Variable: KEYCLOAK_ISSUER_URI
          # Desarrollo: http://localhost:8080/realms/mi-realm
          # Producci√≥n: https://keycloak.production.com/realms/production-realm
          issuer-uri: ${KEYCLOAK_ISSUER_URI:http://localhost:8080/realms/mi-realm}

          # ==========================================
          # jwk-set-uri: ¬øD√≥nde est√°n las claves p√∫blicas?
          # ==========================================
          # Keycloak firma los JWT con su clave PRIVADA.
          # Los microservicios necesitan la clave P√öBLICA para validar la firma.
          #
          # Keycloak publica sus claves p√∫blicas en este endpoint (JWKS).
          # Spring Security descarga estas claves y las usa para validar.
          #
          # Spring hace:
          # 1. Descarga las claves de este endpoint
          # 2. Cachea las claves
          # 3. Valida la firma del JWT usando la clave p√∫blica
          # 4. Si la firma es v√°lida ‚Üí Token aut√©ntico
          # 5. Si la firma es inv√°lida ‚Üí Token rechazado (401)
          #
          # üîß CONFIGURACI√ìN POR VARIABLES DE ENTORNO:
          # Variable: KEYCLOAK_JWK_SET_URI
          # Desarrollo: http://localhost:8080/realms/mi-realm/protocol/openid-connect/certs
          # Producci√≥n: https://keycloak.production.com/realms/production-realm/protocol/openid-connect/certs
          jwk-set-uri: ${KEYCLOAK_JWK_SET_URI:http://localhost:8080/realms/mi-realm/protocol/openid-connect/certs}

# ===============================================
# üîê JWT AUDIENCE VALIDATION
# ===============================================
# Validaci√≥n del claim "aud" para prevenir token reuse
#
# üîß CONFIGURACI√ìN POR VARIABLES DE ENTORNO:
# Variable: JWT_AUDIENCE
# Desarrollo: spring-boot-client
# Producci√≥n: production-client
jwt:
  audience: ${JWT_AUDIENCE:spring-boot-client}

# ===============================================
# üåç CORS CONFIGURATION
# ===============================================
# Configuraci√≥n de CORS (Cross-Origin Resource Sharing)
# Permite que frontends en otros dominios hagan requests al backend
#
# üîß CONFIGURACI√ìN POR VARIABLES DE ENTORNO:
# Variables: CORS_ALLOWED_ORIGINS, CORS_ALLOWED_METHODS, etc.
# Ver .env.example para m√°s detalles
cors:
  allowed-origins: ${CORS_ALLOWED_ORIGINS:http://localhost:4200,http://localhost:3000,http://localhost:8080}
  allowed-methods: ${CORS_ALLOWED_METHODS:GET,POST,PUT,DELETE,OPTIONS,PATCH}
  allowed-headers: ${CORS_ALLOWED_HEADERS:Authorization,Content-Type,X-Requested-With,Accept,Origin}
  exposed-headers: ${CORS_EXPOSED_HEADERS:Authorization,X-Total-Count,X-Page-Number}
  max-age: ${CORS_MAX_AGE:3600}
  allow-credentials: ${CORS_ALLOW_CREDENTIALS:true}

# ===============================================
# EUREKA CLIENT - Service Discovery
# ===============================================
# Configuraci√≥n para que los servicios se registren en Eureka
#
# üîß CONFIGURACI√ìN POR VARIABLES DE ENTORNO:
# Variable: EUREKA_URL
# Desarrollo: http://localhost:8761/eureka/
# Producci√≥n: http://eureka.production.com:8761/eureka/

eureka:
  client:
    serviceUrl:
      defaultZone: ${EUREKA_URL:http://localhost:8761/eureka/}
    register-with-eureka: true
    fetch-registry: true

  instance:
    # Usar IP en vez de hostname (mejor para contenedores)
    prefer-ip-address: true

    # Configuraci√≥n de health check
    lease-renewal-interval-in-seconds: 10
    lease-expiration-duration-in-seconds: 30

# ===============================================
# ACTUATOR - Monitoring y Health Checks
# ===============================================
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus

  endpoint:
    health:
      show-details: always
      probes:
        enabled: true

  health:
    circuitbreakers:
      enabled: true

# ===============================================
# LOGGING
# ===============================================
logging:
  level:
    root: INFO
    com.example: DEBUG
    org.springframework.security: DEBUG  # Ver logs de seguridad (√∫til para debugging)
    org.springframework.security.oauth2: DEBUG

  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} - %msg%n"

# ===============================================
# ¬øPOR QU√â ESTA CONFIGURACI√ìN EST√Å CENTRALIZADA?
# ===============================================
#
# ANTES (sin Config Server):
# ‚ùå Cada microservicio tiene su propia copia de issuer-uri, jwk-set-uri
# ‚ùå Si cambia el realm de Keycloak ‚Üí actualizar 5+ archivos
# ‚ùå Inconsistencias entre servicios
# ‚ùå Secrets duplicados
#
# AHORA (con Config Server):
# ‚úÖ Una sola fuente de verdad
# ‚úÖ Cambio en un solo lugar
# ‚úÖ Todos los servicios obtienen la misma config
# ‚úÖ Secrets centralizados
# ‚úÖ Versionado en Git (puedes hacer rollback)
#
# FLUJO CUANDO UN SERVICIO INICIA:
# 1. Servicio: "Hola Config Server, soy 'user-service'"
# 2. Config Server: "OK, aqu√≠ est√° tu config (application.yml + user-service.yml)"
# 3. Servicio: "Perfecto, ahora s√© c√≥mo validar JWT"
# 4. Spring Security se configura autom√°ticamente
# 5. Servicio listo para recibir requests con JWT
